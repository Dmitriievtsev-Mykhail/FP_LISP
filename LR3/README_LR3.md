# Лабораторна робота 3. Функціональний і імперативний підходи до роботи зі списками
## Мета лабораторної роботи: 
навчитись застосовувати функціональний (рекурсія і конструктивний підхід) і імперативний (цикли і деструктивний підхід) підходи до роботи зі списками при реалізації програм мовою Common Lisp.
Конструктивний і деструктивний підходи розглянуті в розділі 5.1 навчального посібника.
Конструктивні та деструктивні функції для роботи зі списками розглянуті в розділах 4, 5.1, 11 і 12 навчального посібника. Рекурсія розглянута в розділі 10, а циклічні конструкції — в розділі 9. 
Реалізація циклів за допомогою рекурсії розглянута в розділі 10.3. Функції для роботи з багатьма значеннями розглянуті в розділі 6.7.
Реченець виконання роботи (aka дедлайн) визначається викладачем під час видачізавдання на лабораторну роботу.
### 3.1 Завдання
Реалізуйте алгоритм сортування чисел у списку двома способами: функціонально і
імперативно.
1. Функціональний варіант реалізації має базуватись на використанні рекурсії і
конструюванні нових списків щоразу, коли необхідно виконати зміну вхідного списку.
Не допускається використання: псевдо-функцій, деструктивних операцій, циклів,
функцій вищого порядку або функцій для роботи зі списками/послідовностями, що
використовуються як функції вищого порядку. Також реалізована функція не має
бути функціоналом (тобто приймати на вхід функції в якості аргументів).
2. Імперативний варіант реалізації має базуватись на використанні циклів і
деструктивних функцій (псевдофункцій). Не допускається використання функцій
вищого порядку або функцій для роботи зі списками/послідовностями, що
використовуються як функції вищого порядку. Тим не менш, оригінальний список
цей варіант реалізації також не має змінювати, тому перед виконанням
деструктивних змін варто застосувати функцію copy-list (в разі необхідності).
Також реалізована функція не має бути функціоналом (тобто приймати на вхід
функції в якості аргументів).
Алгоритм, який необхідно реалізувати, задається варіантом (п. 3.1.1). Зміст і шаблон звіту
наведені в п. 3.2.
Кожна реалізована функція має бути протестована для різних тестових наборів. Тести
мають бути оформленні у вигляді модульних тестів (наприклад, як наведено у п. 2.3).
